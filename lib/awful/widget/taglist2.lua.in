---------------------------------------------------------------------------
-- @author Uli Schlachter &lt;psychon@znc.in&gt;
-- @copyright 2014 Uli Schlachter
-- @release @AWESOME_VERSION@
---------------------------------------------------------------------------

-- Grab environment we need
------------------------------ TODO: How much of this is really needed?
------------------------------ TODO: What is missing?
local capi = { screen = screen,
               awesome = awesome,
               client = client }
local type = type
local setmetatable = setmetatable
local pairs = pairs
local ipairs = ipairs
local table = table
local common = require("awful.widget.common")
local util = require("awful.util")
local tag = require("awful.tag")
local beautiful = require("beautiful")
local fixed = require("wibox.layout.fixed")
local surface = require("gears.surface")
local util = require("awful.util")
local imagebox = require("wibox.widget.imagebox")
local textbox = require("wibox.widget.textbox")
local background = require("wibox.widget.background")
local margin = require("wibox.layout.margin")
local fixed = require("wibox.layout.fixed")

--- Taglist widget module for awful
-- awful.widget.taglist
local taglist = { mt = {} }
taglist.filter = {}
taglist.widgets = {}

function taglist.widgets.name(t, args)
    if not args then args = {} end
    local theme = beautiful.get()
    local font = args.font or theme.taglist_font or theme.font or ""

    local tb = textbox()
    tb:set_font(font)

    local update = function()
        -- Figure out text for taglist widget
        if not tag.getproperty(t, "icon_only") then
            tb:set_text(t.name or "")
        end
    end

    -- Update the widget when needed
    t:connect_signal("property::name", update)
    --t:connect_signal("property::icon_only", update)
    update()
    return tb
end

function taglist.widgets.icon(t, args)
    if not args then args = {} end
    local theme = beautiful.get()
    local taglist_disable_icon = args.taglist_disable_icon or theme.taglist_disable_icon or false

    local ib = imagebox()

    local update = function()
        -- Get the tag's icon
        if not taglist_disable_icon then
            ib:set_image(surface.load(tag.geticon(t)))
        end
    end

    -- Update the widget when needed
    t:connect_signal("property::icon", update)
    update()
    return ib
end

function taglist.widgets.base(t, args, name, icon)
    if not args then args = {} end
    local theme = beautiful.get()
    -- Get all settings
    local fg_focus = args.fg_focus or theme.taglist_fg_focus or theme.fg_focus
    local bg_focus = args.bg_focus or theme.taglist_bg_focus or theme.bg_focus
    local fg_urgent = args.fg_urgent or theme.taglist_fg_urgent or theme.fg_urgent
    local bg_urgent = args.bg_urgent or theme.taglist_bg_urgent or theme.bg_urgent
    local bg_occupied = args.bg_occupied or theme.taglist_bg_occupied
    local fg_occupied = args.fg_occupied or theme.taglist_fg_occupied
    local bg_empty = args.bg_empty or theme.taglist_bg_empty
    local fg_empty = args.fg_empty or theme.taglist_fg_empty
    local taglist_squares_sel = args.squares_sel or theme.taglist_squares_sel
    local taglist_squares_unsel = args.squares_unsel or theme.taglist_squares_unsel
    local taglist_squares_sel_empty = args.squares_sel_empty or theme.taglist_squares_sel_empty
    local taglist_squares_unsel_empty = args.squares_unsel_empty or theme.taglist_squares_unsel_empty
    local taglist_squares_resize = theme.taglist_squares_resize or args.squares_resize or "true"

    -- Create the widgets
    local tb = (name and name or taglist.widgets.name)(t, args)
    local ib = (icon and icon or taglist.widgets.icon)(t, args)
    local bgb = background()
    local m = margin(tb, 4, 4)
    local l = fixed.horizontal()

    -- All of this is added in a fixed widget
    l:fill_space(true)
    l:add(ib)
    l:add(m)

    -- And all of this gets a background
    bgb:set_widget(l)

    local update = function()
        local sel = capi.client.focus
        local bg_color = nil
        local fg_color = nil
        local bg_image
        local bg_resize = false
        local is_selected = false

        -- Figure out colors and image
        if t.selected then
            bg_color = bg_focus
            fg_color = fg_focus
        end
        if sel and taglist_squares_sel then
            -- Check that the selected clients is tagged with 't'.
            if util.table.hasitem(sel:tags(), t) then
                bg_image = taglist_squares_sel
                bg_resize = taglist_squares_resize == "true"
                is_selected = true
            end
        end
        if t:clients() == 0 and t.selected and taglist_squares_sel_empty then
            bg_image = taglist_squares_sel_empty
            bg_resize = taglist_squares_resize == "true"
        elseif not is_selected then
            local cls = t:clients()
            if #cls > 0 then
                if taglist_squares_unsel then
                    bg_image = taglist_squares_unsel
                    bg_resize = taglist_squares_resize == "true"
                end
                if bg_occupied then bg_color = bg_occupied end
                if fg_occupied then fg_color = fg_occupied end
            else
                if taglist_squares_unsel_empty then
                    bg_image = taglist_squares_unsel_empty
                    bg_resize = taglist_squares_resize == "true"
                end
                if bg_empty then bg_color = bg_empty end
                if fg_empty then fg_color = fg_empty end
            end
            for k, c in pairs(cls) do
                if c.urgent then
                    if bg_urgent then bg_color = bg_urgent end
                    if fg_urgent then fg_color = fg_urgent end
                    break
                end
            end
        end
        bgb:set_bg(bg_color)
        bgb:set_fg(fg_color)
        bgb:set_bgimage(bg_image)
        -- XXX: Do something with bg_resize
    end

    local client_screen_update = function(c)
        if c.screen == tag.getscreen(t) then
            update()
        end
    end

    -- Update the widget when needed
    capi.client.connect_signal("focus", client_screen_update)
    capi.client.connect_signal("property::screen", update) -- No idea which screen it was previously on
    capi.client.connect_signal("property::urgent", client_screen_update)
    capi.client.connect_signal("tagged", client_screen_update)
    capi.client.connect_signal("unfocus", client_screen_update)
    capi.client.connect_signal("unmanage", client_screen_update)
    capi.client.connect_signal("untagged", client_screen_update)
    t:connect_signal("property::activated", update)
    t:connect_signal("property::screen", update)
    t:connect_signal("property::selected", update)

    update()
    return bgb
end

--- Create a new taglist widget. The last two arguments (update_function
-- and base_widget) serve to customize the layout of the taglist (eg. to
-- make it vertical). For that, you will need to copy the
-- awful.widget.common.list_update function, make your changes to it
-- and pass it as update_function here. Also change the base_widget if the
-- default is not what you want.
-- @param screen The screen to draw taglist for.
-- @param filter Filter function to define what clients will be listed.
-- @param buttons A table with buttons binding to set.
-- @param style The style overrides default theme.
-- @param update_function Optional function to create a tag widget on each
--        update. @see awful.widget.common.
-- @param base_widget Optional container widget for tag widgets. Default
--        is wibox.layout.fixed.horizontal().
-- bg_focus The background color for focused client.
-- fg_focus The foreground color for focused client.
-- bg_urgent The background color for urgent clients.
-- fg_urgent The foreground color for urgent clients.
-- squares_sel Optional: a user provided image for selected squares.
-- squares_unsel Optional: a user provided image for unselected squares.
-- squares_sel_empty Optional: a user provided image for selected squares for empty tags.
-- squares_unsel_empty Optional: a user provided image for unselected squares for empty tags.
-- squares_resize Optional: true or false to resize squares.
-- font The font.
--
-- ----------------TODO: Update docs
function taglist.new(screen, filter, buttons, widget_factory, base_widget)
    local filter = filter or function() return true end
    local widget_factory = widget_factory or taglist.widgets.base
    local w = base_widget or fixed.horizontal()
    local data = setmetatable({}, { __mode = 'kv' })
    w.taglist_data = data

    local update = function()
        common.update_list(w, screen, buttons, filter, widget_factory, data, tag.gettags(screen))
    end
    tag.attached_connect_signal(screen, "property::hide", update)
    tag.attached_connect_signal(screen, "property::index", update)
    tag.attached_connect_signal(screen, "property::screen", update)
    update()
    w.gettag = taglist.gettag
    return w
end

-- TODO docs
function taglist:gettag(widget)
    return self.taglist_data[widget]
end

--- Filtering function to include all nonempty, non-hidden tags on the screen.
-- @param t The tag.
-- @return true if t should be shown
function taglist.filter.noempty(t)
    return taglist.filter.all(t) and (#t:clients() > 0 or t.selected)
end

--- Filtering function to include all non-hidden tags on the screen.
-- @param t The tag.
-- @return true if t should be shown
function taglist.filter.all(t)
    return not tag.getproperty(t, "hide")
end

function taglist.mt:__call(...)
    return taglist.new(...)
end

return setmetatable(taglist, taglist.mt)

-- vim: filetype=lua:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:textwidth=80
